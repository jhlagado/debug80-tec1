0000                             ;***************************************
0000                             ;*   MON2 for TEC-1 and compatibles    *
0000                             ;***************************************
0000                             ; Version A
0000                             ; Written by Ken Stone
0000                             ; Decompiled by John Hardy
0000                             ; Commented and optimised by Mark Jelic
0000                             ; 
0000                             ;Keyboard functions:
0000                             ;Shift-Insert range 0900 - 4000 (03FF??)
0000                             ;Shift-Delete range 0900 - 03FF (03FF is set to 00 on use of delete function).
0000                             ;Shift-Address jumps to location stored at 08D2 and 08D3
0000                             ; 
0000                             ;Info:
0000                             ;Stack Start 08C0
0000                             ;Stack Max Length C0
0000                             ;User Code Start 0900
0000                             ;KeyData location 08E0 (placed there by NMI routine)
0000                             ; 
0000                STACKSTART:   EQU   $08C0   ; Stack Max Length C0
0000                VECTOR0:   EQU   $08C0   ; user vector 0
0000                VECTOR1:   EQU   $08C2   ; user vector 1
0000                VECTOR2:   EQU   $08C4   ; user vector 2
0000                VECTOR3:   EQU   $08C6   ; user vector 3
0000                VECTOR4:   EQU   $08C8   ; user vector 4
0000                VECTOR5:   EQU   $08CA   ; user vector 5
0000                VECTOR6:   EQU   $08CC   ; Temporary holder of current address?
0000                SHIFTINS:   EQU   $08D2   
0000                SHIFTDEL:   EQU   $08D4   
0000                TUNEADDR:   EQU   $08D6   
0000                ADDRESS1:   EQU   $08D8   ; current ADDRESS in nibbles over 4 bytes
0000                ADDRESS2:   EQU   $08D9   ; current ADDRESS - nibble #2
0000                ADDRESS3:   EQU   $08DA   ; current ADDRESS - nibble #3
0000                ADDRESS4:   EQU   $08DB   ; current ADDRESS - nibble #4
0000                DATA1:    EQU   $08DC   ; Current DATA in nibbles over two bytes
0000                DATA2:    EQU   $08DD   ; Current DATA - second nibble
0000                MODE:     EQU   $08DF   ; Monitor mode (0 = Address Mode, 1 = Data Mode)
0000                KEYDATA:   EQU   $08E0   ; Key data location updated by NMI routine
0000                X3:       EQU   $08E1   
0000                RAMSTART:   EQU   $0900   ; User Code Start 0900
0000                             ; 
0000                             ; 
0000                STARTROM:   .ORG   $0000   
0000   C3 00 02     RESTART00:   JP   STARTMON   ; Jump to STARTMON @ $0200
0003   FF                     DB   $FF   
0004   FF                     DB   $FF   
0005   FF                     DB   $FF   
0006   FF                     DB   $FF   
0007   FF                     DB   $FF   
0008   2A C0 08     RESTART08:   LD   hl,(VECTOR0)   ;jump to vector stored at $08c0
000B   E9                     JP   (hl)   
000C   FF                     DB   $FF   
000D   FF                     DB   $FF   
000E   FF                     DB   $FF   
000F   FF                     DB   $FF   
0010   2A C2 08     RESTART10:   LD   hl,(VECTOR1)   ;jump to vector stored at $08c2
0013   E9                     JP   (hl)   
0014   FF                     DB   $FF   
0015   FF                     DB   $FF   
0016   FF                     DB   $FF   
0017   FF                     DB   $FF   
0018   2A C4 08     RESTART18:   LD   hl,(VECTOR2)   ;jump to vector stored at $08c4
001B   E9                     JP   (hl)   
001C   FF                     DB   $FF   
001D   FF                     DB   $FF   
001E   FF                     DB   $FF   
001F   FF                     DB   $FF   
0020   2A C6 08     RESTART20:   LD   hl,(VECTOR3)   ;jump to vector stored at $08c6
0023   E9                     JP   (hl)   
0024   FF                     DB   $FF   
0025   FF                     DB   $FF   
0026   FF                     DB   $FF   
0027   FF                     DB   $FF   
0028   2A C8 08     RESTART28:   LD   hl,(VECTOR4)   ;jump to vector stored at $08c8
002B   E9                     JP   (hl)   
002C   FF                     DB   $FF   
002D   FF                     DB   $FF   
002E   FF                     DB   $FF   
002F   FF                     DB   $FF   
0030   2A CA 08     RESTART30:   LD   hl,(VECTOR5)   ;jump to vector stored at $08ca
0033   E9                     JP   (hl)   
0034   FF                     DB   $FF   
0035   FF                     DB   $FF   
0036   FF                     DB   $FF   
0037   FF                     DB   $FF   
0038   2A CC 08     RESTART38:   LD   hl,(VECTOR6)   ;jump to vector stored at $08cc
003B   E9                     JP   (hl)   
003C                             ; 
0066                          .ORG   $066   ;NMI keyboard event
0066   F5           NMINT:    PUSH   af   ;save af ;good idea! fixes Mon1
0067   C5                     PUSH   bc   ;save BC
0068   E5                     PUSH   hl   ;save HL (used in Keyboard Remap)
0069   DB 00                  IN   A,($00)   ;a = key port
006B   47                     LD   B,A   ;save A to B
006C   CD 20 07               CALL   KEYREMAP   
006F   E1                     POP   hl   ;restore hl
0070   C1                     POP   bc   ;restore BC
0071   F1                     POP   af   ;restore af
0072   ED 45                  RETN      ;correct return. fixes Mon1
0074                             ; 
0080                          .ORG   $0080   
0080   EB           SEVSEGDATA:   DB   $EB   ; 0
0081   28                     DB   $28   ; 1
0082   CD                     DB   $CD   ; 2
0083   AD                     DB   $AD   ; 3
0084   2E                     DB   $2E   ; 4
0085   A7                     DB   $A7   ; 5
0086   E7                     DB   $E7   ; 6
0087   29                     DB   $29   ; 7
0088   EF                     DB   $EF   ; 8
0089   2F                     DB   $2F   ; 9
008A   6F                     DB   $6F   ; A
008B   E6                     DB   $E6   ; B
008C   C3                     DB   $C3   ; C
008D   EC                     DB   $EC   ; D
008E   C7                     DB   $C7   ; E
008F   47                     DB   $47   ; F
0090   E3                     DB   $E3   ; G
0091   66                     DB   $66   ; H
0092   28                     DB   $28   ; I
0093   E8                     DB   $E8   ; J
0094   4E                     DB   $4E   ; K
0095   C2                     DB   $C2   ; L
0096   2D                     DB   $2D   ; M
0097   6B                     DB   $6B   ; N
0098   EB                     DB   $EB   ; O
0099   4F                     DB   $4F   ; P
009A   2F                     DB   $2F   ; Q
009B   4B                     DB   $4B   ; R
009C   A7                     DB   $A7   ; S
009D   46                     DB   $46   ; T
009E   EA                     DB   $EA   ; U
009F   E0                     DB   $E0   ; V
00A0   AC                     DB   $AC   ; W
00A1   A4                     DB   $A4   ; X
00A2   AE                     DB   $AE   ; Y
00A3   C9                     DB   $C9   ; Z
00A4   10                     DB   $10   ; .
00A5   08                     DB   $08   ; i
00A6   18                     DB   $18   ; !
00A7   04                     DB   $04   ; -
00A8   2C                     DB   $2C   ; 
00A9   00                     DB   $00   ; space
00AA   6E                     DB   $6E   ; h
00AB   CD                     DB   $CD   ; Z
00AC   FF                     DB   $FF   
00AD   FF                     DB   $FF   
00AE   FF                     DB   $FF   
00AF   FF                     DB   $FF   
00B0                             ; 
00B0                          .ORG   $00B0   
00B0   00           INITADDR:   DB   $00   ;0 inital address (start of RAM)
00B1   09                     DB   $09   ;9
00B2   00                     DB   $00   ;0
00B3   00                     DB   $00   ;0
00B4                             ; 
00C0                          .ORG   $00C0   ; Data table for text message demo.
00C0   1B           DEMOTEXT:   DB   $1b   ; R
00C1   18                     DB   $18   ; O
00C2   1E                     DB   $1e   ; U
00C3   1D                     DB   $1d   ; T
00C4   12                     DB   $12   ; I
00C5   17                     DB   $17   ; N
00C6   0E                     DB   $0e   ; E
00C7   29                     DB   $29   ; [space]
00C8   0B                     DB   $0b   ; B
00C9   22                     DB   $22   ; Y
00CA   29                     DB   $29   ; [space]
00CB   17                     DB   $17   ; N   (Nic. Enots - Ken Stone's old programming pseudonym))
00CC   12                     DB   $12   ; I
00CD   0C                     DB   $0C   ; C
00CE   24                     DB   $24   ; .
00CF   29                     DB   $29   ; [space]
00D0   29                     DB   $29   ; [space]
00D1   29                     DB   $29   ; [space]
00D2   29                     DB   $29   ; [space]
00D3   29                     DB   $29   ; [space]
00D4   FE                     DB   $fe   ; (repeat text)
00D5   1C                     DB   $1c   ; STONE  (Text for real surname hidden in code)
00D6   1D                     DB   $1d   
00D7   18                     DB   $18   
00D8   17                     DB   $17   
00D9   0E                     DB   $0E   
00DA   FF                     DB   $ff   ; (end text)
00DB   FF                     DB   $FF   
00DC   FF                     DB   $FF   
00DD   FF                     DB   $FF   
00DE   FF                     DB   $FF   
00DF   FF                     DB   $FF   
00E0   CD 5B 02     KEYPLUS:   CALL   GETEDITADDR   ;+ key
00E3   03                     INC   bc   
00E4   18 04                  JR   DATAMODE   
00E6   CD 5B 02     KEYMINUS:   CALL   GETEDITADDR   ;- key
00E9   0B                     DEC   bc   
00EA   CD 90 04     DATAMODE:   CALL   SETEDITADDR   
00ED   CD 42 02               CALL   GETADDRDATA   
00F0   21 DF 08               LD   hl,MODE   ; Load HL with the MODE indicator address
00F3   CB C6                  SET   0,(hl)   ; Sets bit 0 of the MODE indicator address to 1, indicating it IS in DATA mode
00F5   CB 8E                  RES   1,(hl)   ; Sets bit 1 of the MODE indicator address to 0, indicating it is NOT in ADDRESS mode
00F7   C3 72 03               JP   POP_HLAF   ; POPs registers HL and AF and Returns
00FA                             ; 
00FA                             ; Division table for frequencies starts here
00FA                             ; First byte is the Length of the Tone, the second is the Frequency
00FA                             ; Higher Frequency tones loop/finish faster, so the Duration needs to be longer.
0100                          .ORG   $0100   
0100   09 FE        FRQTBL:   DB   $09,$FE   
0102   10 FD                  DB   $10,$FD   
0104   11 EF                  DB   $11,$EF   
0106   12 E1                  DB   $12,$E1   
0108   13 D4                  DB   $13,$D4   
010A   14 C9                  DB   $14,$C9   
010C   15 BE                  DB   $15,$BE   
010E   16 B2                  DB   $16,$B2   
0110   17 A9                  DB   $17,$A9   
0112   19 9F                  DB   $19,$9F   
0114   1A 96                  DB   $1A,$96   
0116   1C 8E                  DB   $1C,$8E   
0118   1E 86                  DB   $1E,$86   
011A   20 7F                  DB   $20,$7F   
011C   22 77                  DB   $22,$77   
011E   24 71                  DB   $24,$71   
0120   26 6A                  DB   $26,$6A   
0122   28 64                  DB   $28,$64   
0124   2A 5F                  DB   $2A,$5F   
0126   2D 59                  DB   $2D,$59   
0128   2F 54                  DB   $2F,$54   
012A   32 50                  DB   $32,$50   
012C   35 4B                  DB   $35,$4B   
012E   38 47                  DB   $38,$47   
0130   3C 43                  DB   $3C,$43   
0132   3F 3F                  DB   $3F,$3F   
0134   43 3C                  DB   $43,$3C   
0136   47 38                  DB   $47,$38   
0138   4B 35                  DB   $4B,$35   
013A   50 32                  DB   $50,$32   
013C   54 2F                  DB   $54,$2F   
013E   59 2D                  DB   $59,$2D   
0140   5F 2A                  DB   $5F,$2A   
0142   64 28                  DB   $64,$28   
0144   6A 26                  DB   $6A,$26   
0146   71 24                  DB   $71,$24   
0148   77 22                  DB   $77,$22   
014A   7F 20                  DB   $7F,$20   
014C   86 1E                  DB   $86,$1E   
014E   8E 1C                  DB   $8E,$1C   
0150   96 1A                  DB   $96,$1A   
0152   9F 19                  DB   $9F,$19   
0154   A9 17                  DB   $A9,$17   
0156   B2 16                  DB   $B2,$16   
0158   BE 15                  DB   $BE,$15   
015A   C9 14                  DB   $C9,$14   
015C   D4 13                  DB   $D4,$13   
015E   E1 12                  DB   $E1,$12   
0160   EF 11                  DB   $EF,$11   
0162   FD 10                  DB   $FD,$10   
0164   FE 09                  DB   $FE,$09   
0166                             ; 
0170                          .ORG   $0170   ; a is the tone number
0170   C5           PLAYTONE:   PUSH   bc   ; save bc,de,hl,af
0171   D5                     PUSH   de   
0172   E5                     PUSH   hl   
0173   F5                     PUSH   af   
0174   A7                     AND   a   ; Set Zero flag if A is Zero
0175   20 03                  JR   nz,PTnotZero   ; If the tone in A is 0,
0177   5F                     LD   e,a   ;   then Load E with A (which is Zero)
0178   18 02                  JR   PTZero   ;   and Jump Rel to PTZero
017A   1E 80        PTNOTZERO:   LD   e,$80   ; Else Load E with 80h; high bit is speaker
017C   21 00 01     PTZERO:   LD   hl,FRQTBL   ; Load HL with the base address of the division table for frequencies
017F   87                     ADD   a,a   ; Frequencies are 2 bytes long, so multiply A (tone offset) by 2
0180   85                     ADD   a,l   ; Add the now duplicated offset into L
0181   6F                     LD   l,a   ; Load the result of the addition in L, back into A
0182   4E                     LD   c,(hl)   ; Load the duration of the Tone into C
0183   23                     INC   hl   ; Point HL to the second byte of the freq divisor
0184   46           LENGTHLOOP:   LD   b,(hl)   ; Load the Frequency of the Tone into B
0185   7B                     LD   a,e   ; Load A with E (which is either $00 or $80)
0186   D3 01                  OUT   ($01),a   ; Output A to Port 01
0188   10 FE        HIGHWAVE:   DJNZ   HIGHWAVE   ; repeat while (--b > 0) - Length of high part of "waveform"
018A   46                     LD   b,(hl)   ; restore b
018B   AF                     XOR   a   ; a = 0
018C   D3 01                  OUT   ($01),a   ; speaker bit = 0
018E   10 FE        LOWWAVE:   DJNZ   LOWWAVE   ; repeat while (--b > 0) - Length of low part of "waveform"
0190   0D                     DEC   c   ; c--
0191   20 F1                  JR   nz,LENGTHLOOP   ; if (c != 0) goto lengthloop
0193   F1                     POP   af   ; restore bc,de,hl,af
0194   E1                     POP   hl   
0195   D1                     POP   de   
0196   C1                     POP   bc   
0197   C9                     RET      ; return
0198                             ; 
01A0                          .ORG   $01A0   ; MUSIC routine.
01A0   F5           PLAYTUNE:   PUSH   af   
01A1   E5                     PUSH   hl   
01A2   2A D6 08     STARTTUNE:   LD   hl,(TUNEADDR)   
01A5   7E           LOADNOTE:   LD   a,(hl)   
01A6   FE FF                  CP   $FF   ; If the tune loads a value of FF, signifies end of Tune
01A8   20 03                  JR   nz,PLAYNOTE   
01AA   E1                     POP   hl   
01AB   F1                     POP   af   
01AC   C9                     RET      
01AD   FE FE        PLAYNOTE:   CP   $FE   ; If the tune loads a value of FE, signifies to Repeat the Tune
01AF   28 F1                  JR   z,STARTTUNE   
01B1   23                     INC   hl   
01B2   CD 70 01               CALL   PLAYTONE   ; Subroutine that plays the note loaded in A
01B5   18 EE                  JR   LOADNOTE   
01B7                             ; 
01C0                          .ORG   $01C0   ; The ADDRESS Key routine:
01C0   21 DF 08     KEYADDRESS:   LD   hl,MODE   ; If currently in ADDRESS mode
01C3   CB 46                  BIT   0,(hl)   ; then change the MODE bits to
01C5   20 07                  JR   nz,FLIPON   ; turn it into DATA mode.
01C7   CB C6                  SET   0,(hl)   ; If not in ADDRESS mode, then make it so.
01C9   CB 8E                  RES   1,(hl)   
01CB   C3 72 03               JP   POP_HLAF   
01CE   CB 86        FLIPON:   RES   0,(hl)   
01D0   CB CE                  SET   1,(hl)   
01D2   C3 72 03               JP   POP_HLAF   ; Restore HL and AF then return to calling function.
01D5                             ; 
01D8                          .ORG   $01d8   ; MULTIPASS DISPLAY
01D8   C5                     PUSH   bc   ; Save BC
01D9   06 80                  LD   b,$80   ; B is used as the digit selector
01DB   CD A0 02     MPDISPLAY:   CALL   DISPLAY   ; DISPLAY routine sets the segments according to the data and then lights them up
01DE   10 FB                  DJNZ   MPDISPLAY   ; Repeat for each digit
01E0   C1                     POP   bc   ; Restore BC
01E1   C9                     RET      
01E2   FF                     DB   $FF   
01E3   FF                     DB   $FF   
01E4                             ; 
01E4   ED 4B D2 08  KEYSHPLUS:   LD   bc,(SHIFTINS)   
01E8   CD 90 04               CALL   SETEDITADDR   
01EB   CD 42 02               CALL   GETADDRDATA   
01EE   C3 72 03               JP   POP_HLAF   
01F1   FF                     DB   $FF   
01F2                             ; 
01F2   ED 4B D4 08  KEYSHMINUS:   LD   bc,(SHIFTDEL)   ; Delete and shift down routine
01F6   CD 90 04               CALL   SETEDITADDR   
01F9   CD 42 02               CALL   GETADDRDATA   
01FC   C3 72 03               JP   POP_HLAF   
01FF                             ; 
0200                          .ORG   $0200   ; Main monitor program entry point.
0200                STARTMON:      
0200   21 00 00               LD   HL,$0000   ; Clear the data in VECTOR6
0203   22 CC 08               LD   (VECTOR6),HL   
0206   3E FF                  LD   a,$ff   
0208   32 E0 08               LD   (KEYDATA),a   ; Set the KEY buffer = $FF
020B   31 C0 08               LD   sp,STACKSTART   ; Set stack pointer to $08C0
020E   AF                     XOR   a   ; Clear A
020F   D3 01                  OUT   ($01),a   ; Blank the Diplays
0211   D3 02                  OUT   ($02),a   ; (Do this to ALL ports to clear the 8x8 as well)
0213   D3 03                  OUT   ($03),a   
0215   D3 04                  OUT   ($04),a   
0217   D3 05                  OUT   ($05),a   
0219   D3 06                  OUT   ($06),a   
021B   D3 07                  OUT   ($07),a   
021D   21 B0 00               LD   hl,INITADDR   ; Load HL with $0900, the initial start address
0220   11 D8 08               LD   de,ADDRESS1   ; Load DE with the display address pointer
0223   01 05 00               LD   bc,$0005   ; Load BC with 5
0226   ED B0                  LDIR      ; Copies the 5 (why 5??) bytes from HL to DEMOTEXT
0228   CD 42 02     BEEPMON:   CALL   GETADDRDATA   
022B   3E 08                  LD   a,$08   
022D   CD 70 01               CALL   PLAYTONE   
0230   3E 0F                  LD   a,$0f   
0232   CD 70 01               CALL   PLAYTONE   
0235   3E 01                  LD   a,$01   
0237   32 DF 08               LD   (MODE),a   
023A   CD A0 02     MAINLOOP:   CALL   DISPLAY   
023D   CD 5C 03               CALL   GETKEY   
0240   18 F8                  JR   MAINLOOP   
0242                             ; 
0242   F5           GETADDRDATA:   PUSH   af   ; Loads the data at the current Monitor pointed address
0243   E5                     PUSH   hl   ; and places it into the Display Buffer bytes for digits 1 and 0
0244   C5                     PUSH   bc   ; save registers
0245   CD 5B 02               CALL   GETEDITADDR   ; Loads current address into BC (but is lost, later)
0248   E6 F0                  AND   $f0   ; Mask off the upper nibble. Rotate the byte to move the upper nibble to the lower nibble
024A   0F                     RRCA      
024B   0F                     RRCA      
024C   0F                     RRCA      
024D   0F                     RRCA      
024E   32 DC 08               LD   (DATA1),a   ; Load the left (high) nibble into DATA1 location
0251   0A                     LD   a,(bc)   
0252   E6 0F                  AND   $0f   
0254   32 DD 08               LD   (DATA2),a   ; Load the right (low) nibble into DATA2 location
0257   C1                     POP   bc   
0258   E1                     POP   hl   
0259   F1                     POP   af   
025A   C9                     RET      
025B                             ; 
025B                             ;GetEditorAddress
025B                             ;The address used by editor and shown on the 7 segment display is stored in one
025B                             ;location only, to prevent a situation where displayed address and real address
025B                             ;could differ. In a trade off in processing time, it was more efficient to store
025B                             ;the address in the optimal form for the display routine. As such it needs
025B                             ;converting to and from this format when used by the monitor program.
025B                             ;The chosen location is the display buffer, where the address is broken into
025B                             ;nibbles and spread across four bytes, 08D8, 08D9, 08DA, 08db, MSN to LSN.
025B                             ;GetEditorAddress is used to retrieve this address.
025B                             ;The data held here is only valid while the monitor program is running. As soon as
025B                             ;something else is written to the display it is lost. Resetting the computer
025B                             ;restores it to the default 0900h.
025B                             ; 
025B                             ;GetEditorAddress, when called, loads BC with the address currently held In the
025B                             ;display buffer. It also loads A with the data held at the location addressed by BC.
025B                             ; 
025B                             ; E.G. If the LED display shows 0900 CD, calling GETEDITADDR will load BC with 0900 (B is
025B                             ;the MSB) and loads A with CD. This routine is not transparent. HL is destroyed. BC
025B                             ;and A hold the results. If this routine is called during a user program that is not
025B                             ;an extension to the monitor, the result will have no meaning.
025B   21 D8 08     GETEDITADDR:   LD   hl,ADDRESS1   
025E   7E                     LD   a,(hl)   
025F   07                     RLCA      
0260   07                     RLCA      
0261   07                     RLCA      
0262   07                     RLCA      
0263   23                     INC   hl   
0264   86                     ADD   a,(hl)   
0265   47                     LD   b,a   
0266   23                     INC   hl   
0267   7E                     LD   a,(hl)   
0268   07                     RLCA      
0269   07                     RLCA      
026A   07                     RLCA      
026B   07                     RLCA      
026C   23                     INC   hl   
026D   86                     ADD   a,(hl)   
026E   4F                     LD   c,a   
026F   0A                     LD   a,(bc)   
0270   C9                     RET      
0271                             ; 
02A0                          .ORG   $02A0   
02A0   F5           DISPLAY:   PUSH   af   ;save registers
02A1   E5                     PUSH   hl   
02A2   D5                     PUSH   de   
02A3   C5                     PUSH   bc   ;DE is loaded with the start of the 4 bytes holding
02A4   11 D8 08               LD   de,ADDRESS1   ;the current Monitor Address being displayed
02A7   AF                     XOR   a   ;a = 0
02A8   D3 01                  OUT   ($01),a   ;clear digit port
02AA   CD 50 03               CALL   HEX2SEG   ;Convert the nibble located at DE to into segments and store in A
02AD   CB 4E                  BIT   1,(hl)   ;Check Bit 1 of the MODE register (Address mode)
02AF   28 02                  JR   z,NODOT1   ;If we are in Address mode...
02B1   CB E7                  SET   4,a   ;set segment 4 of digit (decimal point indicating Address mode)
02B3   D3 02        NODOT1:   OUT   ($02),a   ;output a to segment port
02B5   3E 20                  LD   a,$20   ;digit 020 (the left-most digit)
02B7   D3 01                  OUT   ($01),a   ;output a to digit port
02B9   06 20                  LD   b,$20   ;loop count of 20
02BB   10 FE        DELAY1:   DJNZ   DELAY1   ;Allow a count of 20 to show display
02BD   AF                     XOR   a   ;Repeat for 2nd address Digit
02BE   D3 01                  OUT   ($01),a   ;clear digit port
02C0   CD 50 03               CALL   HEX2SEG   ; 
02C3   CB 4E                  BIT   1,(hl)   ; 
02C5   28 02                  JR   z,NODOT2   ; 
02C7   CB E7                  SET   4,a   ; 
02C9   D3 02        NODOT2:   OUT   ($02),a   ;output a to segment port
02CB   3E 10                  LD   a,$10   ;digit 010
02CD   D3 01                  OUT   ($01),a   ;output a to digit port
02CF   06 20                  LD   b,$20   ; 
02D1   10 FE        DELAY2:   DJNZ   DELAY2   ;delay by 20
02D3   AF                     XOR   a   ; 
02D4   D3 01                  OUT   ($01),a   ;clear digit port
02D6   CD 50 03               CALL   HEX2SEG   ; 
02D9   CB 4E                  BIT   1,(hl)   ; 
02DB   28 02                  JR   z,NODOT3   ; 
02DD   CB E7                  SET   4,a   ; 
02DF   D3 02        NODOT3:   OUT   ($02),a   ;output a to segment port
02E1   3E 08                  LD   a,$08   ;digit 080
02E3   D3 01                  OUT   ($01),a   ;output a to digit port
02E5   06 20                  LD   b,$20   ; 
02E7   10 FE        DELAY3:   DJNZ   DELAY3   ;delay by 20
02E9   AF                     XOR   a   ; 
02EA   D3 01                  OUT   ($01),a   ;clear digit port
02EC   CD 50 03               CALL   HEX2SEG   ; 
02EF   CB 4E                  BIT   1,(hl)   ; 
02F1   28 02                  JR   z,NODOT4   ; 
02F3   CB E7                  SET   4,a   
02F5   D3 02        NODOT4:   OUT   ($02),a   ;output a to segment port
02F7   3E 04                  LD   a,$04   ;digit 040
02F9   D3 01                  OUT   ($01),a   ;output a to digit port
02FB   06 20                  LD   b,$20   
02FD   10 FE        DELAY4:   DJNZ   DELAY4   ;delay by 20
02FF   AF                     XOR   a   ; 
0300   D3 01                  OUT   ($01),a   ;clear digit port
0302   00                     NOP      ; 
0303   C3 18 03               JP   DISPLAY2   
0306                             ; 
0306   CD 5B 02     KEYGO:    CALL   GETEDITADDR   ; GO button has been pressed
0309   C5                     PUSH   bc   ; Use the stack to
030A   E1                     POP   hl   ; LD HL with BC
030B   31 C0 08               LD   sp,STACKSTART   
030E   E9                     JP   (hl)   ; Start executing code from the address loaded in HL
030F                             ; 
0318                          .ORG   $0318   ; 
0318   CD 50 03     DISPLAY2:   CALL   HEX2SEG   ; DISPLAY2 displays the two Data Digits (5th & 6th)
031B   CB 46                  BIT   0,(hl)   ; Check if we are in DATA mode
031D   28 02                  JR   z,$0321   ; If we are then...
031F   CB E7                  SET   4,a   ; Set the dot to indicate DATA mode.
0321   D3 02        NODOT5:   OUT   ($02),a   
0323   3E 02                  LD   a,$02   ;digit 020
0325   D3 01                  OUT   ($01),a   ;output a to digit port
0327   06 20                  LD   b,$20   
0329   10 FE        DELAY5:   DJNZ   DELAY5   ;delay by 20
032B   AF                     XOR   a   
032C   D3 01                  OUT   ($01),a   ;clear digit port
032E   CD 50 03               CALL   HEX2SEG   
0331   CB 46                  BIT   0,(hl)   
0333   28 02                  JR   z,NODOT6   
0335   CB E7                  SET   4,a   
0337   D3 02        NODOT6:   OUT   ($02),a   
0339   3E 01                  LD   a,$01   ;digit 040
033B   D3 01                  OUT   ($01),a   ;output a to digit port
033D   06 20                  LD   b,$20   
033F   10 FE        DELAY6:   DJNZ   DELAY6   ;delay by 20
0341   AF                     XOR   a   
0342   D3 01                  OUT   ($01),a   ;clear digit port
0344   C1                     POP   bc   ;restore registers
0345   D1                     POP   de   
0346   E1                     POP   hl   
0347   F1                     POP   af   
0348   C9                     RET      ;return
0349                             ; 
0349                             ;Hex2SevenSeg converts the Hex value (0 to 29) into the
0349                             ;corresponding seven-segment data. It is part of the display routine.
0349                             ;HL is destroyed, DE is incremented, A is converted from the value to its
0349                             ;7 segment form.
0350                          .ORG   $0350   ;Hex2SevenSeg
0350   21 80 00     HEX2SEG:   LD   hl,SEVSEGDATA   ;HL pointing to start of 7seg data
0353   1A                     LD   a,(de)   ;Load A with the contents of (de) - but what is at (de)?
0354   85                     ADD   a,l   ;Add L to the contents of A
0355   6F                     LD   l,a   ;Then load A back into L
0356   7E                     LD   a,(hl)   ;a = (hl + a)
0357   13                     INC   de   ;de++
0358   21 DF 08               LD   hl,MODE   ;hl = mode
035B   C9                     RET      ;return
035C                             ; 
035C   F5           GETKEY:   PUSH   af   ; KEYDATA is the keyboard buffer address
035D   E5                     PUSH   hl   ; which is filled with $FF after the key data is read
035E   21 E0 08               LD   hl,KEYDATA   ;hl = KEYDATA
0361   3E FF                  LD   a,$ff   
0363   BE                     CP   (hl)   ; if the buffer still holds $FF,
0364   28 0C                  JR   z,POP_HLAF   ; no key pressed and return
0366   7E                     LD   a,(hl)   ;  a = (KEYDATA)
0367   E6 1F                  AND   $1f   ;  Mask off the high 3 bits
0369   CB 6E                  BIT   5,(hl)   ;  test if the Shift bit 5 is on
036B   20 02                  JR   nz,NOSHIFT   ;  if (shift) is on, then
036D   C6 14                  ADD   a,$14   ;    add $14 to the contents of A
036F   C3 98 03     NOSHIFT:   JP   KEYBLIP   
0372                             ; 
0372   E1           POP_HLAF:   POP   hl   ;restore hl, af
0373   F1                     POP   af   
0374   C9                     RET      
0375                             ; 
0375                             ; Routine used to effectively delete a byte of data
0375   CD 5B 02     SHIFTMEMDN:   CALL   GETEDITADDR   ; by shifting all data above current address down one byte.
0378                             ; BC has the current memory address.
0378   C5                     PUSH   bc   ; Using the stack...
0379   DD E1                  POP   ix   ; Load IX with the contents of BC
037B   DD 23        LOOPDOWN:   INC   ix   ; Increment IX (so it points to Current+1)
037D   DD E5                  PUSH   ix   ; Use stack to copy IX...
037F   E1                     POP   hl   ; and load it into HL
0380   7C                     LD   a,h   
0381   FE 40                  CP   $40   ; Check if we are at max memory address of $4000
0383   28 08                  JR   z,MAXMEM   ; if so, then jump... else...
0385   DD 7E 00               LD   a,(ix+0)   ; Load A with data at (IX) which is Current+1
0388   DD 77 FF               LD   (ix-1),a   ; Save the data to the current memory location
038B   18 EE                  JR   LOOPDOWN   ; Loop back and do it again
038D                             ; 
038D   3E 00        MAXMEM:   LD   a,$00   ; Clear A
038F   32 FF 3F               LD   ($3fff),a   ; Load $00 into the top memory location.
0392   CD 42 02               CALL   GETADDRDATA   
0395   C3 72 03               JP   POP_HLAF   
0398                             ; 
0398   C6 01        KEYBLIP:   ADD   a,$01   ; Not sure why $01 is added... Makes it a higher tone?
039A   CD 70 01               CALL   PLAYTONE   ; Key blip that goes higher for each key - Which is annoying, TBH
039D   C3 1C 04               JP   WHICHKEY   
03A0                             ; 
03A0   CD 5B 02     SHIFTMEMUP:   CALL   GETEDITADDR   
03A3   0B                     DEC   bc   
03A4   DD 21 FE 3F            LD   ix,$3ffe   ; Select the 2nd to last byte and then
03A8   DD 7E 00     LOOPUP:   LD   a,(ix+0)   ; Copy it into the highest byte
03AB   DD 77 01               LD   (ix+1),a   ; then repeat until the BC = HL
03AE   DD 2B                  DEC   ix   
03B0   DD E5                  PUSH   ix   
03B2   E1                     POP   hl   
03B3   79                     LD   a,c   
03B4   BD                     CP   l   
03B5   20 F1                  JR   nz,LOOPUP   ; Repeat until C = L
03B7   78                     LD   a,b   
03B8   BC                     CP   h   
03B9   20 ED                  JR   nz,LOOPUP   ; Repeat until B = H
03BB   DD 36 01 00            LD   (ix+1),$00   
03BF   CD 42 02               CALL   GETADDRDATA   
03C2   C3 72 03               JP   POP_HLAF   
03C5                             ; 
03D8                          .ORG   $03d8   ; RUNNING WRITING
03D8   E5           RUNWRITING:   PUSH   hl   ; Save registers
03D9   F5                     PUSH   af   
03DA   DD E5                  PUSH   ix   
03DC   C5                     PUSH   bc   
03DD   AF                     XOR   a   ; Clear A
03DE   32 DF 08               LD   (MODE),a   ; Set MODE to 0
03E1   06 06                  LD   b,$06   ; Load B with 6 (number of display digits)
03E3   21 D8 08               LD   hl,ADDRESS1   ; load HL with the current user memory address
03E6   3E 29                  LD   a,$29   ; not sure why you'd load A with 29H ??
03E8   77           LOAD29H:   LD   (hl),a   ; Put A (with 29H) into (HL)
03E9   23                     INC   hl   ; 
03EA   10 FC                  DJNZ   LOAD29H   ; Loop 6 times
03EC   2A DC 08     REPEATMSG:   LD   hl,(DATA1)   ; 
03EF   7E           LOADCHAR:   LD   a,(hl)   ; 
03F0   FE FF                  CP   $ff   ; Is the character just loaded an $FF (signifies end of string)
03F2   20 06                  JR   nz,STARTMSG   ;    If not, then JUMP to...
03F4   C1                     POP   BC   ; otherwise restore the registers
03F5   DD E1                  POP   ix   
03F7   F1                     POP   af   
03F8   E1                     POP   hl   
03F9   C9                     RET      ; and end the routine
03FA   FE FE        STARTMSG:   CP   $fe   ; org $3FA
03FC   28 EE                  JR   z,REPEATMSG   ; if the character is $FE, this marks it as the Repeat message
03FE   DD 21 D8 08            LD   ix,ADDRESS1   
0402   06 05                  LD   b,$05   ; Loop count $05
0404   DD 7E 01     DISROTL:   LD   a,(ix+1)   ; Rotate right 5 digits to the left
0407   DD 77 00               LD   (ix+0),a   
040A   DD 23                  INC   ix   
040C   10 F6                  DJNZ   DISROTL   ; Loop back till 5 digits done
040E   7E                     LD   a,(hl)   
040F   32 DD 08               LD   (DATA2),a   
0412   23                     INC   hl   
0413   06 40                  LD   b,$40   ; Loop count $40
0415   CD A0 02     DISLOOP:   CALL   DISPLAY   ; org $0415
0418   10 FB                  DJNZ   DISLOOP   ; Multiplex the Display $40 times
041A   18 D3                  JR   LOADCHAR   
041C                             ; 
041C   D6 01        WHICHKEY:   SUB   $01   ; Subtract the $01 that was added for the Key Blip
041E   36 FF                  LD   (hl),$ff   ; Reset the Keyboard buffer back to $FF
0420   CB 67                  BIT   4,a   ; Test if bit 4 (the control keys) is set
0422   C2 C0 04               JP   nz,CTRLKEY   ;   If so, jumpt to the routine handling non-data keys
0425   CB 6F                  BIT   5,a   ; Test if the SHIFT key is pressed
0427   C2 C0 04               JP   nz,CTRLKEY   ;   If so, jumpt to the routine handling non-data keys
042A   21 DF 08               LD   hl,MODE   
042D   CB 46                  BIT   0,(hl)   ; Check MODE-0
042F   CA 55 04               JP   z,MODE0OFF   ;   Jump if MODE-0 is off
0432   57                     LD   d,a   
0433   CD 5B 02               CALL   GETEDITADDR   
0436   21 DF 08               LD   hl,MODE   
0439   CB 5E                  BIT   3,(hl)   ; Is MODE-3 on?
043B   20 03                  JR   nz,MODE3ON   ; If so, then jump
043D   AF                     XOR   a   ; Set A to 0
043E   CB DE                  SET   3,(hl)   ; Set MODE-3 to ON
0440   07           MODE3ON:   RLCA      ; Rotate lower nibble to top
0441   07                     RLCA      
0442   07                     RLCA      
0443   07                     RLCA      
0444   E6 F0                  AND   $f0   ; Mask off the lower data
0446   82                     ADD   a,d   
0447   02                     LD   (bc),a   
0448   CD 42 02               CALL   GETADDRDATA   
044B   C3 72 03               JP   POP_HLAF   
044E                             ; 
0455                          .ORG   $0455   ; 
0455   57           MODE0OFF:   LD   d,a   
0456   21 DF 08               LD   hl,MODE   
0459   CB 9E                  RES   3,(hl)   
045B   CB 66                  BIT   4,(hl)   
045D   20 08                  JR   nz,MODEJUMP   
045F   01 00 00               LD   bc,$0000   
0462   CD 90 04               CALL   SETEDITADDR   
0465   CB E6                  SET   4,(hl)   
0467   CD 5B 02     MODEJUMP:   CALL   GETEDITADDR   
046A   78                     LD   a,b   
046B   07                     RLCA      
046C   07                     RLCA      
046D   07                     RLCA      
046E   07                     RLCA      
046F   E6 F0                  AND   $f0   
0471   5F                     LD   e,a   
0472   79                     LD   a,c   
0473   07                     RLCA      
0474   07                     RLCA      
0475   07                     RLCA      
0476   07                     RLCA      
0477   E6 0F                  AND   $0f   
0479   83                     ADD   a,e   
047A   47                     LD   b,a   
047B   79                     LD   a,c   
047C   07                     RLCA      
047D   07                     RLCA      
047E   07                     RLCA      
047F   07                     RLCA      
0480   E6 F0                  AND   $f0   
0482   82                     ADD   a,d   
0483   4F                     LD   c,a   
0484   CD 90 04               CALL   SETEDITADDR   
0487   CD 42 02               CALL   GETADDRDATA   
048A   C3 72 03               JP   POP_HLAF   
048D                             ; 
048D                             ;SetEditorAddress is the opposite of the GetEditorAddress routine.
048D                             ;It loads the display buffer (ADDRESS1 - ADDRESS4) with the
048D                             ;value held in BC. No registers affected.
048D                             ; 
0490                          .ORG   $0490   ;SetEditorAddress
0490   F5           SETEDITADDR:   PUSH   af   ;save af, hl
0491   E5                     PUSH   hl   
0492   21 D8 08               LD   hl,ADDRESS1   ;hl points to ADDRESS buffer
0495   78                     LD   a,b   ;a = b
0496   E6 F0                  AND   $f0   ;mask out lower nibble
0498   07                     RLCA      ;rotate upper nibble into lower nibble
0499   07                     RLCA      
049A   07                     RLCA      
049B   07                     RLCA      
049C   77                     LD   (hl),a   ;(hl) = a
049D   23                     INC   hl   ;hl++
049E   78                     LD   a,b   ;a = b
049F   E6 0F                  AND   $0f   ;mask lower nibble
04A1   77                     LD   (hl),a   ;(hl) = a
04A2   23                     INC   hl   ;hl++
04A3   79                     LD   a,c   ;a = c
04A4   E6 F0                  AND   $f0   ;mask upper nibble
04A6   07                     RLCA      ;rotate upper nibble into lower nibble
04A7   07                     RLCA      
04A8   07                     RLCA      
04A9   07                     RLCA      
04AA   77                     LD   (hl),a   ;(hl) = a
04AB   23                     INC   hl   ;hl++
04AC   79                     LD   a,c   ;a = c
04AD   E6 0F                  AND   $0f   ;mask lower nibble
04AF   77                     LD   (hl),a   ;Save A into location (HL)
04B0   E1                     POP   hl   ;restore hl, af
04B1   F1                     POP   af   
04B2   C9                     RET      ;return
04B3                             ; 
04C0                          .ORG   $04C0   ; 
04C0   21 DF 08     CTRLKEY:   LD   hl,MODE   ; A big CASE routine to determine which control key is pressed
04C3   CB 9E                  RES   3,(hl)   ; This modifies the MODE setting.
04C5   CB A6                  RES   4,(hl)   
04C7   FE 10                  CP   $10   
04C9   CA E0 00               JP   z,KEYPLUS   ; The PLUS key was pressed
04CC   FE 11                  CP   $11   
04CE   CA E6 00               JP   z,KEYMINUS   ; The MINUS key was pressed
04D1   FE 12                  CP   $12   
04D3   CA 06 03               JP   z,KEYGO   ; The GO button was pressed
04D6   FE 13                  CP   $13   
04D8   CA C0 01               JP   z,KEYADDRESS   ; The ADdress button was pressed
04DB   FE 14                  CP   $14   
04DD   CA 42 05               JP   z,SHIFTJUMP   ; The SHIFT and ADdress key is pressed
04E0   FE 15                  CP   $15   
04E2   CA FF FF               JP   z,$ffff   
04E5   FE 16                  CP   $16   
04E7   CA FF FF               JP   z,$ffff   
04EA   FE 17                  CP   $17   
04EC   CA F2 01               JP   z,KEYSHMINUS   
04EF   FE 18                  CP   $18   
04F1   CA 70 05               JP   z,USERPOSTBURN   ; USER burnt routine in EPROM after release.
04F4   FE 19                  CP   $19   
04F6   CA FF FF               JP   z,$ffff   
04F9   FE 1A                  CP   $1a   
04FB   CA FF FF               JP   z,$ffff   
04FE   FE 1B                  CP   $1b   
0500   CA FF FF               JP   z,$ffff   
0503   FE 1C                  CP   $1c   
0505   CA 60 06               JP   z,$0660   
0508   FE 1D                  CP   $1d   
050A   CA FF FF               JP   z,$ffff   
050D   FE 1E                  CP   $1e   
050F   CA FF FF               JP   z,$ffff   
0512   FE 1F                  CP   $1f   
0514   CA FF FF               JP   z,$ffff   
0517   FE 20                  CP   $20   
0519   CA FF FF               JP   z,$ffff   
051C   FE 21                  CP   $21   
051E   CA FF FF               JP   z,$ffff   
0521   FE 22                  CP   $22   
0523   CA FF FF               JP   z,$ffff   
0526   FE 23                  CP   $23   
0528   CA FF FF               JP   z,$ffff   
052B   FE 24                  CP   $24   
052D   CA A0 03               JP   z,SHIFTMEMUP   ; The SHIFT and PLUS keys
0530   FE 25                  CP   $25   
0532   CA 75 03               JP   z,SHIFTMEMDN   ; The SHIFT and MINUS keys
0535   FE 26                  CP   $26   
0537   CA FF FF               JP   z,$ffff   
053A   FE 27                  CP   $27   
053C   CA E4 01               JP   z,KEYSHPLUS   
053F   C3 72 03               JP   POP_HLAF   
0542                             ; 
0542   CD 5B 02     SHIFTJUMP:   CALL   GETEDITADDR   
0545   60                     LD   h,b   
0546   69                     LD   l,c   
0547   3A E1 08               LD   a,(X3)   
054A   23           LOOPJUMP:   INC   hl   
054B   BE                     CP   (hl)   
054C   20 FC                  JR   nz,LOOPJUMP   
054E   44                     LD   b,h   
054F   4D                     LD   c,l   
0550   CD 90 04               CALL   SETEDITADDR   
0553   C3 28 02               JP   BEEPMON   
0556                             ; 
0570                          .ORG   $0570   
0570   00           USERPOSTBURN:   DB   $00   
0571                             ; 
0700                          .ORG   $0700   ;Keyboard Remap Data
0700   00 01 02 03            DB   $00,$01,$02,$03   ;This key map is the original TEC-1 layout.
0704   04 05 06 07            DB   $04,$05,$06,$07   ;Keep the same data structure, but change the
0708   08 09 0A 0B            DB   $08,$09,$0A,$0B   ;values to REMAP the data read from the 74C923
070C   0C 0D 0E 0F            DB   $0C,$0D,$0E,$0F   ;to any keyboard layout you wish.
0710   10                     DB   $10   ;Plus Key
0711   11                     DB   $11   ;Minus Key
0712   12                     DB   $12   ;Go Key
0713   13                     DB   $13   ;Address Key
0714                             ; 
0714                             ;.ORG $0700                              ;An Alternative Keyboard Map with Monitor Keys on the right.
0714                             ;                DB $0F, $02, $05, $08   ;
0714                             ;                DB $0E, $03, $06, $09   ;
0714                             ;                DB $0D, $0C, $0B, $0A   ;
0714                             ;                DB $10, $11, $12, $13   ;
0714                             ;                DB $00                  ;Plus Key
0714                             ;                DB $01                  ;Minus Key
0714                             ;                DB $04                  ;Go Key
0714                             ;                DB $07                  ;Address Key
0714                             ; 
0720                          .ORG   $0720   ;Remap keys to Table specified @ $0700
0720   E6 1F        KEYREMAP:   AND   $1f   ;mask lower 5 bits
0722   26 07                  LD   H,$07   ;Use the table at $0700 to load A with a key value
0724   6F                     LD   L,A   
0725   7E                     LD   A,(HL)   
0726   CB 68                  BIT   5,B   ;Test if Shift Key was pressed
0728   28 02                  JR   Z,SAVEKEY   ;Shift is pressed - Skip next line
072A   CB EF                  SET   5,A   ;Set Bit 5 High to avoid Shift processing
072C   32 E0 08     SAVEKEY:   LD   (KEYDATA),a   ;save A into ram
072F   C9                     RET      
0730                             ; 
07F0                          .ORG   $07F0   ;VERSION DATA
07F0   4D 4F 4E 32 2E 41 31 20 VERSION:   DB   "MON2.A1 "   
07F8   32 30 32 32 2E 4D 4A 20 DB   "2022.MJ "   


STACKSTART:         08C0 DEFINED AT LINE 20
                    > USED AT LINE 344
                    > USED AT LINE 485
VECTOR0:            08C0 DEFINED AT LINE 21
                    > USED AT LINE 50
VECTOR1:            08C2 DEFINED AT LINE 22
                    > USED AT LINE 56
VECTOR2:            08C4 DEFINED AT LINE 23
                    > USED AT LINE 62
VECTOR3:            08C6 DEFINED AT LINE 24
                    > USED AT LINE 68
VECTOR4:            08C8 DEFINED AT LINE 25
                    > USED AT LINE 74
VECTOR5:            08CA DEFINED AT LINE 26
                    > USED AT LINE 80
VECTOR6:            08CC DEFINED AT LINE 27
                    > USED AT LINE 86
                    > USED AT LINE 341
SHIFTINS:           08D2 DEFINED AT LINE 28
                    > USED AT LINE 327
SHIFTDEL:           08D4 DEFINED AT LINE 29
                    > USED AT LINE 333
TUNEADDR:           08D6 DEFINED AT LINE 30
                    > USED AT LINE 293
ADDRESS1:           08D8 DEFINED AT LINE 31
                    > USED AT LINE 354
                    > USED AT LINE 406
                    > USED AT LINE 432
                    > USED AT LINE 598
                    > USED AT LINE 614
                    > USED AT LINE 698
ADDRESS2:           08D9 DEFINED AT LINE 32
ADDRESS3:           08DA DEFINED AT LINE 33
ADDRESS4:           08DB DEFINED AT LINE 34
DATA1:              08DC DEFINED AT LINE 35
                    > USED AT LINE 377
                    > USED AT LINE 603
DATA2:              08DD DEFINED AT LINE 36
                    > USED AT LINE 380
                    > USED AT LINE 621
MODE:               08DF DEFINED AT LINE 37
                    > USED AT LINE 197
                    > USED AT LINE 307
                    > USED AT LINE 363
                    > USED AT LINE 528
                    > USED AT LINE 596
                    > USED AT LINE 634
                    > USED AT LINE 639
                    > USED AT LINE 656
                    > USED AT LINE 727
KEYDATA:            08E0 DEFINED AT LINE 38
                    > USED AT LINE 343
                    > USED AT LINE 533
                    > USED AT LINE 823
X3:                 08E1 DEFINED AT LINE 39
                    > USED AT LINE 783
RAMSTART:           0900 DEFINED AT LINE 40
STARTROM:           0000 DEFINED AT LINE 43
RESTART00:          0000 DEFINED AT LINE 44
RESTART08:          0008 DEFINED AT LINE 50
RESTART10:          0010 DEFINED AT LINE 56
RESTART18:          0018 DEFINED AT LINE 62
RESTART20:          0020 DEFINED AT LINE 68
RESTART28:          0028 DEFINED AT LINE 74
RESTART30:          0030 DEFINED AT LINE 80
RESTART38:          0038 DEFINED AT LINE 86
NMINT:              0066 DEFINED AT LINE 90
SEVSEGDATA:         0080 DEFINED AT LINE 102
                    > USED AT LINE 522
INITADDR:           00B0 DEFINED AT LINE 152
                    > USED AT LINE 353
DEMOTEXT:           00C0 DEFINED AT LINE 158
KEYPLUS:            00E0 DEFINED AT LINE 190
                    > USED AT LINE 731
KEYMINUS:           00E6 DEFINED AT LINE 193
                    > USED AT LINE 733
DATAMODE:           00EA DEFINED AT LINE 195
                    > USED AT LINE 192
FRQTBL:             0100 DEFINED AT LINE 206
                    > USED AT LINE 268
PLAYTONE:           0170 DEFINED AT LINE 259
                    > USED AT LINE 303
                    > USED AT LINE 359
                    > USED AT LINE 361
                    > USED AT LINE 569
PTNOTZERO:          017A DEFINED AT LINE 267
                    > USED AT LINE 264
PTZERO:             017C DEFINED AT LINE 268
                    > USED AT LINE 266
LENGTHLOOP:         0184 DEFINED AT LINE 274
                    > USED AT LINE 283
HIGHWAVE:           0188 DEFINED AT LINE 277
                    > USED AT LINE 277
LOWWAVE:            018E DEFINED AT LINE 281
                    > USED AT LINE 281
PLAYTUNE:           01A0 DEFINED AT LINE 291
STARTTUNE:          01A2 DEFINED AT LINE 293
                    > USED AT LINE 301
LOADNOTE:           01A5 DEFINED AT LINE 294
                    > USED AT LINE 304
PLAYNOTE:           01AD DEFINED AT LINE 300
                    > USED AT LINE 296
KEYADDRESS:         01C0 DEFINED AT LINE 307
                    > USED AT LINE 737
FLIPON:             01CE DEFINED AT LINE 313
                    > USED AT LINE 309
MPDISPLAY:          01DB DEFINED AT LINE 320
                    > USED AT LINE 321
KEYSHPLUS:          01E4 DEFINED AT LINE 327
                    > USED AT LINE 777
KEYSHMINUS:         01F2 DEFINED AT LINE 333
                    > USED AT LINE 745
STARTMON:           0200 DEFINED AT LINE 339
                    > USED AT LINE 44
BEEPMON:            0228 DEFINED AT LINE 357
                    > USED AT LINE 790
MAINLOOP:           023A DEFINED AT LINE 364
                    > USED AT LINE 366
GETADDRDATA:        0242 DEFINED AT LINE 368
                    > USED AT LINE 196
                    > USED AT LINE 329
                    > USED AT LINE 335
                    > USED AT LINE 357
                    > USED AT LINE 565
                    > USED AT LINE 587
                    > USED AT LINE 651
                    > USED AT LINE 688
GETEDITADDR:        025B DEFINED AT LINE 406
                    > USED AT LINE 190
                    > USED AT LINE 193
                    > USED AT LINE 371
                    > USED AT LINE 482
                    > USED AT LINE 549
                    > USED AT LINE 572
                    > USED AT LINE 638
                    > USED AT LINE 663
                    > USED AT LINE 780
DISPLAY:            02A0 DEFINED AT LINE 428
                    > USED AT LINE 320
                    > USED AT LINE 364
                    > USED AT LINE 624
NODOT1:             02B3 DEFINED AT LINE 439
                    > USED AT LINE 437
DELAY1:             02BB DEFINED AT LINE 443
                    > USED AT LINE 443
NODOT2:             02C9 DEFINED AT LINE 450
                    > USED AT LINE 448
DELAY2:             02D1 DEFINED AT LINE 454
                    > USED AT LINE 454
NODOT3:             02DF DEFINED AT LINE 461
                    > USED AT LINE 459
DELAY3:             02E7 DEFINED AT LINE 465
                    > USED AT LINE 465
NODOT4:             02F5 DEFINED AT LINE 472
                    > USED AT LINE 470
DELAY4:             02FD DEFINED AT LINE 476
                    > USED AT LINE 476
KEYGO:              0306 DEFINED AT LINE 482
                    > USED AT LINE 735
DISPLAY2:           0318 DEFINED AT LINE 489
                    > USED AT LINE 480
NODOT5:             0321 DEFINED AT LINE 493
DELAY5:             0329 DEFINED AT LINE 497
                    > USED AT LINE 497
NODOT6:             0337 DEFINED AT LINE 504
                    > USED AT LINE 502
DELAY6:             033F DEFINED AT LINE 508
                    > USED AT LINE 508
HEX2SEG:            0350 DEFINED AT LINE 522
                    > USED AT LINE 435
                    > USED AT LINE 446
                    > USED AT LINE 457
                    > USED AT LINE 468
                    > USED AT LINE 489
                    > USED AT LINE 500
GETKEY:             035C DEFINED AT LINE 531
                    > USED AT LINE 365
NOSHIFT:            036F DEFINED AT LINE 542
                    > USED AT LINE 540
POP_HLAF:           0372 DEFINED AT LINE 544
                    > USED AT LINE 200
                    > USED AT LINE 312
                    > USED AT LINE 315
                    > USED AT LINE 330
                    > USED AT LINE 336
                    > USED AT LINE 536
                    > USED AT LINE 566
                    > USED AT LINE 588
                    > USED AT LINE 652
                    > USED AT LINE 689
                    > USED AT LINE 778
SHIFTMEMDN:         0375 DEFINED AT LINE 549
                    > USED AT LINE 773
LOOPDOWN:           037B DEFINED AT LINE 553
                    > USED AT LINE 561
MAXMEM:             038D DEFINED AT LINE 563
                    > USED AT LINE 558
KEYBLIP:            0398 DEFINED AT LINE 568
                    > USED AT LINE 542
SHIFTMEMUP:         03A0 DEFINED AT LINE 572
                    > USED AT LINE 771
LOOPUP:             03A8 DEFINED AT LINE 575
                    > USED AT LINE 582
                    > USED AT LINE 585
RUNWRITING:         03D8 DEFINED AT LINE 591
LOAD29H:            03E8 DEFINED AT LINE 600
                    > USED AT LINE 602
REPEATMSG:          03EC DEFINED AT LINE 603
                    > USED AT LINE 613
LOADCHAR:           03EF DEFINED AT LINE 604
                    > USED AT LINE 626
STARTMSG:           03FA DEFINED AT LINE 612
                    > USED AT LINE 606
DISROTL:            0404 DEFINED AT LINE 616
                    > USED AT LINE 619
DISLOOP:            0415 DEFINED AT LINE 624
                    > USED AT LINE 625
WHICHKEY:           041C DEFINED AT LINE 628
                    > USED AT LINE 570
MODE3ON:            0440 DEFINED AT LINE 644
                    > USED AT LINE 641
MODE0OFF:           0455 DEFINED AT LINE 655
                    > USED AT LINE 636
MODEJUMP:           0467 DEFINED AT LINE 663
                    > USED AT LINE 659
SETEDITADDR:        0490 DEFINED AT LINE 696
                    > USED AT LINE 195
                    > USED AT LINE 328
                    > USED AT LINE 334
                    > USED AT LINE 661
                    > USED AT LINE 687
                    > USED AT LINE 789
CTRLKEY:            04C0 DEFINED AT LINE 727
                    > USED AT LINE 631
                    > USED AT LINE 633
SHIFTJUMP:          0542 DEFINED AT LINE 780
                    > USED AT LINE 739
LOOPJUMP:           054A DEFINED AT LINE 784
                    > USED AT LINE 786
USERPOSTBURN:       0570 DEFINED AT LINE 793
                    > USED AT LINE 747
KEYREMAP:           0720 DEFINED AT LINE 816
                    > USED AT LINE 95
SAVEKEY:            072C DEFINED AT LINE 823
                    > USED AT LINE 821
VERSION:            07F0 DEFINED AT LINE 827
